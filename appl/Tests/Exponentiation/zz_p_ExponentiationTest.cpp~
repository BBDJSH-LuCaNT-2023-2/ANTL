/**
 * @file zz_p_expo_test.cpp
 * @author Michael Jacobson
 * @brief Test program for exponentiation routines using zz_p as base type.
 */

#include <NTL/lzz_p.h>
#include <ANTL/Exponentiation/ExponentiationBinary.hpp>
#include <ANTL/Exponentiation/ExponentiationNAF.hpp>
#include <ANTL/Exponentiation/ExponentiationL2R.hpp>
#include <ANTL/Exponentiation/ExponentiationWNAF.hpp>


void zz_p::cub(zz_p C, const zz_p A){
          sqr(C,A);
          mul(C,C,A);
          }

#include <ANTL/Exponentiation/ExponentiationSB3.hpp>



NTL_CLIENT
using namespace ANTL;
	
int main (int argc, char **argv)
{
  zz_p a,b_bin,b_naf, b_l2r, b_wnaf, b_sb3;
  ZZ n;

  // use GF(1073741827) for these tests
  zz_p::init(1073741827);

  // set base to be a random value in GF(5)
  do {
    random(a);
  } while (IsOne(a));


  // generate random exponent of size 128 bits
  RandomLen (n, 12);

  cout << "Using:" << endl;
  cout << " p = " << zz_p::modulus() << endl;
  cout << " a = " << a << endl;
  cout << " n = " << n << endl;

  cout << "Cube Test: " << endl;

  cub(b_sb3,a);
  
  cout << "a^3 = " << b_sb3 << endl;


  // initialize exponentiation classes
  ExponentiationBinary<zz_p> ebin;
  ExponentiationNAF<zz_p> enaf;
  ExponentiationL2R<zz_p> el2r;
  ExponentiationWNAF<zz_p> ewnaf;
  ExponentiationSB3<zz_p> esb3;

  // compute a^n with available methods
  ebin.power(b_bin,a,n);

  enaf.initialize(a,n);
  enaf.power(b_naf,a,n);

  el2r.initialize(a);
  el2r.power(b_l2r,a,n);

  ewnaf.initialize(a,n,5);
  ewnaf.power(b_wnaf,a,n);
 
  esb3.initialize(a,n);
  esb3.power(b_sb3,a,n);

  // check and output results
  cout << "a^n (binary) = " << b_bin << endl;
  cout << "a^n (naf)    = " << b_naf << endl;
  cout << "a^n (l2r)    = " << b_l2r << endl;
  cout << "a^n (wnaf)   = " << b_wnaf << endl;
  cout << "a^n (sb3)    = " << b_sb3 << endl;

  if ((b_bin == b_naf) && (b_naf == b_l2r) && (b_wnaf == b_bin) && (b_sb3 == b_bin))
    cout << "RESULTS MATCH!" << endl;
  else
    cout << "ERROR:  RESULTS DO NOT MATCH!" << endl;
}
