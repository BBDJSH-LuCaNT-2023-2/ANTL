#ifndef ANTL_CUBIC_IDEAL_NF_H
#define ANTL_CUBIC_IDEAL_NF_H

/**
 * @file CubicIdealNF.hpp
 * @author Randy Yee
 * @remarks Class representing ideals of cubic number fields.
 */



#include "CubicOrderNF.hpp"
#include "CubicElementNF.hpp"
#include "CubicIdeal.hpp"
#include "../Arithmetic/QQ.hpp"

using namespace ANTL;

// class forward declarations
template<typename Type,typename PType>
class CubicOrderNF;
template<typename Type,typename PType>
class CubicElementNF;
template<typename Type,typename PType>
class CubicIdeal;
template<typename Type,typename PType>
class IdealMultiplicationStrategy;


template<typename Type,typename PType>
class CubicIdealNF : public CubicIdeal<Type, PType>{

template<typename T,typename PT>
friend class IdealMultiplicationStrategy;


public:


/************** Constructor(s) **********************/
CubicIdealNF(const CubicOrderNF<Type,PType> * cnfo, const CubicElementNF<Type,PType> & A,
  const CubicElementNF<Type,PType> & B, const CubicElementNF<Type,PType> & C);


/************** Accessors **********************/

inline const CubicElementNF<Type, PType> * get_gen1() const {return &gen1;}
inline const CubicElementNF<Type, PType> * get_gen2() const {return &gen2;}
inline const CubicElementNF<Type, PType> * get_gen3() const {return &gen3;}
inline const Type get_denom () const {return denom;}


//
//Type norm();
bool is_equivalent(const CubicIdeal<Type, PType> & B);
Type norm();
/**
* @brief function to determine whether the ideal is principal. Not yet implemented
*/
bool is_principal();

/**
* @brief function to determine whether the ideal is prime. Not yet implemented
*/
bool is_prime();

/**
* @brief function to determine whether the ideal is equivalent to B. Not yet implemented
*/

bool is_canonical();

/**
* @brief function to obtain an equivalent reduced ideal. Not yet implemented
*/
void reduce();

/**
* @brief function to change the basis into canonical form. Not yet implemented
*/
void become_canonical();

/**
* @brief function to obtain a prepared basis. Not yet implemented
*/
void become_prepared();

/**
* @brief function to implement a single step of Voronoi's algorithm: that is, to obtain
* an equivalent ideal via dividing this ideal A by the principal ideal generated by the
* minima adjacent to 1 in the corresponding 1-lattice. Not yet implemented
*/
void voronoi();

/******************** friends *********************/
/**
* @brief the mul method
*
*/
//template <typename T, typename PT>
//friend void MultiplyStrategyWilliams<T, PT> :: multiply(CubicIdealNF<Type,PType>  &A, const CubicIdealNF<Type,PType>  &B, const CubicIdealNF<Type,PType> &C);


protected:

  // a Z basis for the ideal, should be of size 3
  // The representation will always be as 3 integral elements all over a common denominator
  Type ci_temp;
  CubicElementNF<Type, PType> gen1;
  CubicElementNF<Type, PType> gen2;
  CubicElementNF<Type, PType> gen3;
  Type denom = Type(1);

  void normalize();

private:




}; // close class definition
#include "../../../src/Cubic/CubicIdealNF.cpp"
#endif
