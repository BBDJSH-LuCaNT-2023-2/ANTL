#ifndef ANTL_CUBIC_IDEAL_NF_H
#define ANTL_CUBIC_IDEAL_NF_H

/**
 * @file CubicIdealNF.hpp
 * @author Randy Yee
 * @remarks Class representing ideals of cubic number fields.
 */



#include "CubicOrderNF.hpp"
#include "CubicElementNF.hpp"
#include "CubicIdeal.hpp"
#include "../Arithmetic/QQ.hpp"

using namespace ANTL;

// class forward declarations
template<typename Type,typename PType>
class CubicOrderNF;
template<typename Type,typename PType>
class CubicElementNF;
template<typename Type,typename PType>
class CubicIdeal;
template<typename Type,typename PType>
class IdealMultiplicationStrategy;


template<typename Type,typename PType>
class CubicIdealNF : public CubicIdeal<Type, PType>{

template<typename T,typename PT>
friend class IdealMultiplicationStrategy;


public:


/************** Constructor(s) **********************/
CubicIdealNF(const CubicOrderNF<Type,PType> * cnfo, const CubicElementNF<Type,PType> & A,
  const CubicElementNF<Type,PType> & B, const CubicElementNF<Type,PType> & C);


/************** Accessors **********************/

inline const CubicElementNF<Type, PType> * get_gen1() const {return &gen1;}
inline const CubicElementNF<Type, PType> * get_gen2() const {return &gen2;}
inline const CubicElementNF<Type, PType> * get_gen3() const {return &gen3;}
inline const Type get_denom () const {return denom;}



void assign(const CubicElementNF<Type, PType> g3, const CubicElementNF<Type, PType> g2, const CubicElementNF<Type, PType> g1);
void assign(const Type U1, const Type X1, const Type Y1, const Type D1,
const Type U2, const Type X2, const Type Y2, const Type D2,
const Type U3, const Type X3, const Type Y3, const Type D3);
//
//Type norm();


bool is_integral(){
  return IsOne(this->denom);
};

/**
* @brief this function checks whether two ideals are the same by comparing their
* lattices
*/
bool is_equal(const CubicIdeal<Type, PType> & B);


bool is_equivalent(const CubicIdeal<Type, PType> & B);
Type norm();
/**
* @brief function to determine whether the ideal is principal. Not yet implemented
*/
bool is_principal();

/**
* @brief function to determine whether the ideal is prime. Not yet implemented
*/
bool is_prime();

/**
* @brief function to determine whether the ideal is equivalent to B. Not yet implemented
*/

bool is_canonical();

/**
* @brief function to obtain an equivalent reduced ideal. Not yet implemented
*/
void reduce();

/**
* @brief function to change the basis into canonical form. Not yet implemented
*
* Important note: To take into account fractional ideals, the assumed state of the
* ideal is as (1/sigma)*J, where sigma is minimal and J is an integral ideal
* Proceed to operate on L1, the 1-lattice corresponding to I,
* L1 = sigma * L2, where L2 corresponds to J
* In hindsight, maybe this isnt as complicated as all that. It's basically
* Find the HNF of J
*/
void become_canonical();

/**
* @brief function to obtain a prepared basis. Not yet implemented
*/
void become_prepared();

/**
* @brief function to implement a single step of Voronoi's algorithm: that is, to obtain
* an equivalent ideal via dividing this ideal A by the principal ideal generated by the
* minima adjacent to 1 in the corresponding 1-lattice. Not yet implemented
*/
void voronoi();

/******************** friends *********************/
/**
* @brief the mul method
*
*/
//template <typename T, typename PT>
//friend void MultiplyStrategyWilliams<T, PT> :: multiply(CubicIdealNF<Type,PType>  &A, const CubicIdealNF<Type,PType>  &B, const CubicIdealNF<Type,PType> &C);


protected:

  // a Z basis for the ideal, should be of size 3
  // The representation will always be as 3 integral elements all over a common denominator
  static Type ci_temp, ci_temp2, ci_temp3;
  CubicElementNF<Type, PType> gen1;
  CubicElementNF<Type, PType> gen2;
  CubicElementNF<Type, PType> gen3;
  Type denom = Type(1);

  void normalize();

private:




}; // close class definition
#include "../../../src/Cubic/CubicIdealNF.cpp"
#endif
