#ifndef ANTL_CUBIC_IDEAL_H
#define ANTL_CUBIC_IDEAL_H

/**
 * @file CubicIdeal.hpp
 * @author Randy Yee
 * @remarks Class representing a generic cubic ideal.
 */



#include "CubicOrderNF.hpp"
#include "CubicElementNF.hpp"
#include "../Arithmetic/QQ.hpp"

using namespace ANTL;


template<typename Type,typename PType>
class CubicIdeal{


public:


/************** Accessors **********************/
inline const CubicOrder<Type, PType> * get_order() const {return my_order;}
inline CubicElement<Type, PType> * get_gen1() const {return gen1;}
inline CubicElement<Type, PType> * get_gen2() const {return gen2;}
inline CubicElement<Type, PType> * get_gen3() const {return gen3;}
inline Type get_denom () const {return denom;}



//
Type norm();

/**
* @brief function to determine whether the ideal is principal. Not yet implemented
*/
bool is_principal();

/**
* @brief function to determine whether the ideal is prime. Not yet implemented
*/
bool is_prime();

/**
* @brief function to determine whether the ideal is equivalent to B. Not yet implemented
*/
bool is_equivalent(const CubicIdeal<Type, PType> & B);
bool is_canonical();

/**
* @brief function to obtain an equivalent reduced ideal. Not yet implemented
*/
void reduce();

/**
* @brief function to change the basis into canonical form. Not yet implemented
*/
void become_canonical();

/**
* @brief function to obtain a prepared basis. Not yet implemented
*/
void become_prepared();

/**
* @brief function to implement a single step of Voronoi's algorithm: that is, to obtain
* an equivalent ideal via dividing this ideal A by the principal ideal generated by the
* minima adjacent to 1 in the corresponding 1-lattice. Not yet implemented
*/
void voronoi();

/******************** friends *********************/
friend void mul<Type, PType > (CubicIdeal<Type, PType> & A, const CubicIdeal<Type, PType> & B, const CubicIdeal<Type, PType> & C);
protected:


// holds a reference to the order in which the ideal sits in
CubicOrder<Type, PType> * my_order;


// a Z basis for the ideal, should be of size 3
// The representation will always be as 3 integral elements all over a common denominator
CubicElement<Type, PType> gen1;
CubicElement<Type, PType> gen2;
CubicElement<Type, PType> gen3;
Type denom = Type(1);

private:

static Type ci_temp;

virtual void normalize();


}; // close class definition

#endif
