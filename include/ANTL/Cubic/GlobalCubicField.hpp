#ifndef ANTL_GLOBAL_CUBIC_FIELD_H
#define ANTL_GLOBAL_CUBIC_FIELD_H

/**
 * @file GlobalCubicField.hpp
 * @author Randy Yee
 * @brief Abstract class for Global Cubic Fields, specializes to CubicNumberField
 * and in the future to CubicFunctionField
 */

 #include <sstream>
 #include <string>
 #include <NTL/RR.h>
 #include <NTL/ZZX.h>
 #include <NTL/ZZ.h>
 #include <boost/math/tools/polynomial.hpp>
 #include <boost/multiprecision/gmp.hpp>
 #include "../common.hpp"
 #include "../Arithmetic/QQ.hpp"


 #include "GeneralTemplateFunctions.hpp"
 #include "CubicOrderReal.hpp"
 #include "Multiplication/IdealMultiplicationStrategy.hpp"
 #include "Multiplication/MultiplyStrategyWilliams.hpp"
 #include "VoronoiMethods.hpp"
 #include "VoronoiComplex.hpp"
 #include "VoronoiReal.hpp"
 using boost::math::tools::polynomial;
 using NTL::abs;



using namespace NTL;
using boost::math::tools::polynomial;
// It is intended that Type is the datatype for integers
// and that PType holds real numbers.
template <typename Type, typename PType>
class GlobalCubicField {

public:

  //****************** accessor functions (functional) ***********************//

  /** Returns the basis */
  Type get_discriminant(){return discriminant;}
  PType* get_basis(){return &basis;}

  /** @brief function to return the equation order, i.e the value f such that disc(P) = f^2* disc(K)
  * where K is the field, and P is the definingPolynomial
  */
  long get_equation_order(){return equationOrder;}
  polynomial<Type>* get_defining_polynomial(){return &definingPolynomial;}
  CubicOrder<Type, PType>* get_maximal_order(){return maximalOrder;}



  // constructors

  GlobalCubicField(Type &A, Type &B, Type &C, Type &D);
  GlobalCubicField(polynomial<Type> const &poly);
  GlobalCubicField(long A, long B, long C, long D);
  GlobalCubicField();
  ~GlobalCubicField();
private:



protected:
// The defining polynomial, the field is generated by a root of this //
  boost::math::tools::polynomial<Type> definingPolynomial;

  Type discriminant;

  // Maximal order
  CubicOrder<Type, PType> *maximalOrder;

  //this is a Q-basis for the field. In the Number Field case, we can take
  // 1, delta, delta^2, where delta is a real root of defining_polynomial.
  PType basis[3];
  // Since the defining polynomial may not correspond to a maximal order
  // this keeps track of what order it corresponds to.
  long equationOrder;


  virtual void calc_discriminant() = 0;
  virtual void set_integral_basis() = 0;
};


#include "../../../src/Cubic/GlobalCubicField.cpp"


#endif //guard
